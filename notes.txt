---
Allow loading .obj geometry onto a body.
---
Have rays.

Class {
  name: "Ray"
  Param {
    name: "origin"
    type: Point
  }
  Param {
    name: "direction"
    type: Vector
  }
  Line {
    start: origin
    end: origin + direction*1000
  }
}
Class {
  name: "PointOnRay"
  Param {
    name: "ray"
    type: Ray
  }
  Param {
    name: "step"
    type: Float
  }
  ray.origin + ray.direction*step
}

Should we have markers as children of rays?

A ray could just be geometry.  It could be an infinite line along the X
axis starting at (0,0,0).  We could change the ray origin and direction
using a body.

Maybe we have a list of rays on a body.

A body can be thought of as three rays with a common origin.

We could have body markers and ray markers, where a ray marker just has
a step value.
---
How would we generalize this to have multiple solving passes?
* It seems like we are effectively setting up multiple solve tags.
  Maybe each solver has a solve tag associated with it.  Each value
  can be tagged with any of the solve tags.
  * Potentially a value could have a number of tags and a solver could
    have a number of tags and the values that get solved are the ones
    where there are matching tags.
  * Potentially an error could also have a tag, maybe a different set of tags.
* We may want to have local solvers.
  * For example, if we are trying to make rays point in the right direction,
    we could have a local solver for each ray which makes the ray point
    in the right direction relative to the camera, and then we have a
    solver for each camera which makes the camera translate and rotate
    to match rays in 3D, then we have another solver which tries to
    make 3D points which match the rays. The camera solver and the point
    solver could be combined into a larger solver which solves both.
---
Instead of having different kinds of errors, we could just be able to put
an error on various values.

Distance {
  start_marker: "marker1"
  end_marker: "marker2"
  value: 2.3 {
    error: 5 {
      desired_value: 7.3
      weight: 1
    }
  }
}

Body {
  translation: [] {
    x: 3 {
      error: 1 {
        desired_value: 2
        weight: 1
      }
    }
  }
---
It might be nice to treat a handle on a marker as setting temporary
desired values and solving rather than setting the values directly.
* This would allow for us moving markers which are driven by expressions.
* It would end up solving variables and moving the marker to the closest
  position that was supported by the variables.

An example of where this is useful is if we're trying to make a body be
scalable.  We can have a variable which represents the scale, and we can
set the scale of the box on the body to use the variable.  We can also
have each marker on the body have its position be multiplied by the
scale factor.  Currently, this would make it where we can't move markers
on the body.

One thing that seems missing is the ability to specify an expression for
the position of a marker which depends on the marker position's components.
We'd want to have an expression like: [x*scale, y*scale, z*scale].  When
setting the marker position, we could calculate the component values.
We would try to calculate scale.
---
I think bodies should have scale.
* The scale would be a single value.
* The scale would change the position of markers on the body.
* The scale would change the effective scale of the child bodies.
---
