---
Seems like it would make sense to be able to select two markers and then
create a distance error between them.  I'm not sure what the interaction
here is though.  The most intuitive thing seems to be right-clicking
on the 3D view and having a context menu which says "Add Distance Error".
---
I'd like to be able to take an existing body and create another version of
it as a child of another body at the same global location.

* steps
  * Select a body
  * duplicate
  * cut
  * Select another body
  * paste child global
* notes
  * we could potentially select multiple source bodies and multiple target
    bodies and create a copy of each source on each target
  * we can reparent a body by
    * steps
      * select a body
      * cut
      * select another body
      * paste child global
    * We lose any distance errors that are not children of the body this way.
      * If we support having distance errors that are children of bodies, then
        this wouldn't be as big of a problem.
  * having duplicate instead of copy seems a bit better, since we can't
    easily make several copies of a body onto the same parent using just copy
    and paste child global, but we can easily copy a body onto another
    body by using duplicate, cut and paste child global
---
If we cut a body and paste it, we lose the distance errors.
* We could potentially remember the distance errors that are connected.
  * This might be nice, because we could
* We could allow distance errors to be children of a body.
  * This seems like a good alternative.
  * For this to work without having objects reference later objects, we
    would need to move the markers so that they appear before the bodies.
    * Scene
      * [Marker] global1
      * [Body]
        * [Marker] local1
        * [DistanceError] local1 <-> global1
* We could have a different way of moving a body that doesn't involve removing
  it first.
---
Allow adding distance errors to bodies.
* This will mean removing/adding distance errors to the tree when we
  remove or add bodies.
---
I think a cut should work like in a spreadsheet, where the items are just
marked as cut, but are still in the scene.  This will allow connections
to be maintained until the destination is chosen.
Somehow you should be disallowed from pasting into a cut object.

It seems like the cut object should be shown differently somehow.

Cuts are very transient.  Basically anything that affects the scene will
remove the cut.  This means we should just be able to store the body index
or the marker index that is cut, since anything that might change the
index would clear the cut.  If we modify the value of a cut object, then
it will clear the cut also.

We need a way to show items in the tree that are cut.  Maybe greying
the text color is good enough.

How can we change the text color of items in the tree?

Cutting a body and pasting to a body with a higher index involves adjusting
the index of the pasted body.

If we were cutting and pasting a marker, we would want to preserve
the connections to any distance errors.  Because the SceneState manages
the invariant that distance errors must refer to valid markers, this
implies that the transfer has to be done in the scene state.

* Remove object from tree
* Remove object from scene
* Transfer object to new location
* Add object to tree
* Add object to scene

This has some issues because we've previously assumed that the tree and
scene would closely match the scene state.  For example, we could not
have any child bodies of the body being removed from the scene, and
we assumed that we could check that by checking the scene state, and
not having to check the scene itself.

It seems intuitive that we would be able to ask a tree to remove a branch
and it would be able to do that regardless of whether the branch had
descendants, but there's some tricky issues with the indices.  As we
remove bodies, if the indices of the body paths in the tree will
shift and we'll get out of sync.

Maybe it needs to be in two phases.  The first phase removes the items
from the tree without changing the tree paths, and we remember the indices
of the bodies and markers that were removed.  In a second phase, we remove
a set of bodies and markers from the tree paths.  We can do that relatively
easy by traversing these indices in reverse order.

We may be able to section out the logic a bit better if we have a function
which determines the bodies and the markers in a hierarchy.

vector<BodyIndex> body_indices;
vector<MarkerIndex> marker_indices;

We can then first call a function to determine the index set for a hierarchy,
then remove this index set from the tree, remove it from the scene, and
remove it from the state.

If the index set is in topological order, then we can do this fairly
efficiently.

It would be nice to just
* remove body from tree
* remove body from scene
* change the body's parent
* add body to scene
* add body to tree

It seems difficult to make this work using indices.  We can't easily maintain
having the SceneState and the TreePaths and the SceneHandles be out of
sync for more than one thing at a time.  One possibility is to clear the
items of the the scene and the tree without removing the indices.  To make
this work, we'd really need to have all the slots in the TreePaths and
SceneHandles be optional so we can know which ones have been removed.
This will also be good if we decided to move away from having indices to
having some other kind of stable id for bodies and markers, so that
we could have empty slots indicating those ids aren't used.
