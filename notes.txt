---
Allow loading .obj geometry onto a body.
---
Have rays.

Class {
  name: "Ray"
  Param {
    name: "origin"
    type: Point
  }
  Param {
    name: "direction"
    type: Vector
  }
  Line {
    start: origin
    end: origin + direction*1000
  }
}
Class {
  name: "PointOnRay"
  Param {
    name: "ray"
    type: Ray
  }
  Param {
    name: "step"
    type: Float
  }
  ray.origin + ray.direction*step
}

Should we have markers as children of rays?

A ray could just be geometry.  It could be an infinite line along the X
axis starting at (0,0,0).  We could change the ray origin and direction
using a body.

Maybe we have a list of rays on a body.

A body can be thought of as three rays with a common origin.

We could have body markers and ray markers, where a ray marker just has
a step value.
---
How would we generalize this to have multiple solving passes?
* It seems like we are effectively setting up multiple solve tags.
  Maybe each solver has a solve tag associated with it.  Each value
  can be tagged with any of the solve tags.
  * Potentially a value could have a number of tags and a solver could
    have a number of tags and the values that get solved are the ones
    where there are matching tags.
  * Potentially an error could also have a tag, maybe a different set of tags.
* We may want to have local solvers.
  * For example, if we are trying to make rays point in the right direction,
    we could have a local solver for each ray which makes the ray point
    in the right direction relative to the camera, and then we have a
    solver for each camera which makes the camera translate and rotate
    to match rays in 3D, then we have another solver which tries to
    make 3D points which match the rays. The camera solver and the point
    solver could be combined into a larger solver which solves both.
---
Instead of having different kinds of errors, we could just be able to put
an error on various values.

Distance {
  start_marker: "marker1"
  end_marker: "marker2"
  value: 2.3 {
    error: 5 {
      desired_value: 7.3
      weight: 1
    }
  }
}

Body {
  translation: [] {
    x: 3 {
      error: 1 {
        desired_value: 2
        weight: 1
      }
    }
  }
---
A nice visual representation of error is a line to the closest point.  If
we have an X error, then a line to the point with the minimum y and z values
would be a good representation of that error.
---
Seems like we're going to want to have a set of expressions and an indication
of where the value goes.  When we are solving the scene state, we'll go
through all the expressions and evaluate them and store the values in
the appropriate fields.

The alternative would be to keep an expression as part of each thing we
could set.

From the standpoint of the scene solver, any value we are solving is
a variable.  So we could have a variable in the scene state, which isn't
being solved, so it is effectively a constant.

Ultimately, we need to build an expression graph.  Some nodes in the graph
will be solved and others won't.

It seems like the solve flags are similar to the expressions.  The values
that we might want to solve could also be driven by expressions.

Seems like the idea behind how the spin boxes work isn't quite right.
We're having the spin boxes evaluate the expression, so we treating
changing the expression string like putting in a numeric value.  We get a
callback from the tree widget indicating that the numeric value of an
item has changed.  But we really need to set the expression on the item
instead.

We already have an evaluator callback in the tree widget.  We could utilize
this as a way to update the expressions.
---
It would be nice to have a more generic way to visit scene items.
* For example, if we have a tree path, it would be nice to be able to
  visit the corresponding item in the scene state.
* I could imaging having some kind of generic path:
  &SceneState::bodies, index, &SceneState::Body::translation, &SceneState::XYZ::x
* Seems like we'd have some kind of template that could take a path like
  this and give us something else, like a tree path or a solve flag, or
  an expression.
---
Enable ADD_TEST in observedscene_test.cpp
---
It seems like we may want to have it where we change the type of a channel
by opening the item and choosing from an option menu.
* translation: []
  * x: 2.5
    * type: constant
    * solve: false
    * minimum:
    * maximum:
    * precision
* translation: []
  * x: 2.5
    * type: constant
    * solve: true
    * minimum:
    * maximum:
    * precision
* translation: []
  * x: 2.5
    * type: expression
    * expression: "x+2"
    * minimum:
    * maximum:
    * precision
---
BodyChannels
body_id tx_channel_id ty_channel_id tz_channel_id rx_channel_id ry_channel_id rz_channel_id

ChannelExpressions
channel_id expression

In some ways, it seems like it would be nice to have generic channels.  When
we create a body, we would allocate channels for the body transform components.
We could then iterate through all the channels. When we use expressions, we
could reference channels.  So if something like body.translation.x was used in
an expression, we would just be mapping that to the appropriate channel.
When we build the error evaluator, the channels will become nodes in a graph.
We'd need to make sure to deallocate channels when we remove bodies.

Another approach is to have the transform components be channels.  With this
approach, we no longer have a generic way to refer to a channel. We'd have
to have different kinds of channels (BodyTranslationXChannelRef,
BodyTranslationYChannelRef, etc.)

Another approach would be to have channels but on a per-body basis. i.e.
each body has a set of channels associated with it.  This would give us
a way to to refer to any channel by a (body_id, channel_number) pair.
In our particular case, we could have hard-coded channel numbers since we
know exactly which things in a body have channels.  This is basically
the same as having an enum for the different channels.
---
If we change a variable, then click on a spin box that is using that variable
in an expression, then it doesn't show the expression.

If we're changing the value of a variable and that variable is being used
in an expression for a body transform (i.e. x translation), and that transform
is being solved, the behavior is surprising.  When you change the variable, the
body doesn't move because the scene is re-solved.  Seems like we have a few
options.
* Be smarter about how we re-solve the scene.
  * Temporarily disable the solving for any channel that is affected by
    the variable that is being changed.
* Automatically disable the solve flag when we change a channel to use an
  expression.
  * Maybe the solve flag is still sensitive, so we can turn it back on if we
    want.
  * This may be a better behavior in general.  Even if we just change the value
    of the channel by typing in a number or using the arrows on the spin box,
    we could disable the solve.  The user coule re-enable it whenever they
    want.
